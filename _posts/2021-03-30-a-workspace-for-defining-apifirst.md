---
published: true
layout: post
title: 'A Workspace for Defining API-First'
image: https://kinlane-productions2.s3.amazonaws.com/a-workspace-for-defining-apifirst.png
tags:
    - Workspace
    - API-First
---

Alongside [my API lifecycle public workspace](https://www.postman.com/api-evangelist/workspace/api-life-cycle/overview) I have established an [API-first public workspace](https://www.postman.com/api-evangelist/workspace/api-first/overview) to help me guide conversations around what is API-first. Like the API lifecycle it is another area we use a lot, but donâ€™t always have a coherent and relatable meaning behind exactly what it means. To get really meta, I am using an API-first process to define the API-first process (mind blown). I am using Postman to define an OpenAPI, which provides me with a structure and schema for how I will be defining API-first, but then I use collection examples to store the API-first definition I am evolving, then I mock and document it to make it a little more tangible, making it all available in a single API workspace.

[![](https://kinlane-productions2.s3.amazonaws.com/a-workspace-for-defining-apifirst.png)](https://www.postman.com/api-evangelist/workspace/api-first/overview)

I am looking to get more precise when I talk about the API lifecycle and API-first. There is no better way to be precise than using an API defined using an API-first process. I learned a lot by setting up the OpenAPI, collections, environment, and mock server for this definition. It pushed me to think a little more deeply about what it is I am trying to define, and pushed me to separate the scaffolding and framework for the definition, from the actual details of the implementation. The API-first workspace provides me with a framework and definition for pushing me forward in this journey, but it also makes it accessible to others to join in via the public workspace, and contribute to the framework via the OpenAPI, or the actual API-first definition using the collection, allowing anyone to fork and submit pull requests, or just leave feedback via the API or collection level comments.