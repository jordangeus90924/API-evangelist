---published: truelayout: posttitle: 'Some Of The API Gateway Building Blocks'image: https://s3.amazonaws.com/kinlane-productions2/algorotoscope-master/udnie-IMG_8312.jpg---
<p><img src="https://s3.amazonaws.com/kinlane-productions2/algorotoscope-master/udnie-IMG_8312.jpg" width="45%" align="right" style="padding: 15px;" />
The inspiration for this post wasn’t fully mine, I’m borrowing and building upon what Sukanya Santhanam (@SukanyaSanthan1) <a href="https://twitter.com/SukanyaSanthan1/status/1151424256300859392">tweeted out the other day</a>. It is a good idea, and something that should be open sourced and moved forward. I’ve been studying with API management since 2010, and using gateways for over 15 years. I’ve watched gateways evolve, and partnered regularly with API management and gateway providers (Shout out to Tyk). Modern API gateways aren’t your grandfather’s SOA tooling, they’ve definitely gone through several iterations. While I still prefer hand rolling and forging my APIs out back in my woodshed on an anvil, I find myself working with a lot of different API gateways lately.

<p>I’ve kept feeling like I needed to map out the layers of what I’d consider to be a modern API gateway, and begin providing links to the most relevant API gateways out there, and the most common building blocks for an API gateway. Now that you can find API gateways baked into the fabric of the cloud, it is time that we work to standardize the definition of what they can deliver. I’m not looking to change what already is. Actually, I’m looking to just document and build on what already is. As with every other stop along the API lifecycle I’m looking to just map out the common building blocks, and establish a blueprint going forward the might influence existing API gateway providers, as well as any newcomers.

<p>After going through my <a href="http://gateway.apievangelist.com/">API gateway research</a> for a while, I quickly sketched out these common building blocks for helping deploy, manage, monitor, and secure your APIs:

<ul>
  <li><strong>Paths</strong> - Allowing many different API paths to exist.</li>
  <li><strong>Schema</strong> - Allowing me to manage all of my schema.</li>
  <li><strong>Integrations</strong> - Providing backend lego architecture.
    <ul>
      <li><strong>Resource</strong> - Allow for integration with other APIs.</li>
      <li><strong>Database</strong> - Provide a stack of database integrations.</li>
      <li><strong>Other</strong> - Define whole buffet of integration definitions.</li>
    </ul>
  </li>
  <li><strong>Requests</strong> - Define all of my HTTP 1.1 requests
    <ul>
      <li><strong>Methods</strong> - Providing me with my HTTP verbs.</li>
      <li><strong>Path Parameters</strong> - Able to define path parameters.</li>
      <li><strong>Query Parameters</strong> - Able to define query parameters.</li>
      <li><strong>Bodies</strong> - Providing control over the request body.</li>
      <li><strong>Headers</strong> - Full management of HTTP request headers.</li>
      <li><strong>Encoding</strong> - Defining the media types in in use for requests.</li>
      <li><strong>Validate</strong> - Providing validation for all incoming requests.</li>
      <li><strong>Mappings</strong> - Allowing for mapping of requests to backend.</li>
      <li><strong>Transformations</strong> - Transformation before sending to backend..</li>
      <li><strong>Examples</strong> - Ensuring there are samples for each request.</li>
      <li><strong>Schema</strong> - Able to reference all schema used in requests.</li>
      <li><strong>Tags</strong> - Being able to organize API requests using tags.</li>
    </ul>
  </li>
  <li><strong>Responses</strong> - Define all of my HTTP 1.1 responses.
    <ul>
      <li><strong>Status Code</strong>s - Providing the ability to define HTTP status codes.</li>
      <li><strong>Headers</strong> - Full management of all HTTP response headers.</li>
      <li><strong>Encoding</strong> - Defining the media types in in use for responses.</li>
      <li><strong>Schema</strong> - Able to reference all schema used in responses.</li>
      <li><strong>Examples</strong> - Ensuring there are samples for each response.</li>
    </ul>
  </li>
  <li><strong>Stages</strong> - Able to stage APIs under any platform defined environment.</li>
  <li><strong>Publishing</strong> - Allowing for conscious publishing of APIs into production.</li>
  <li><strong>Versioning</strong> - Providing semantic versioning as header or in the path.</li>
  <li><strong>Policies</strong> - Defining policies for API, and schema access by consumers.</li>
  <li><strong>Licensing</strong> - Ensure that data and APIs are properly licensed for consumption.</li>
  <li><strong>Plans</strong> - Crafting a handful of standard access tiers for different consumers.</li>
  <li><strong>Rate Limiting</strong> - Define the rate limits for all APIs within each plan offered.</li>
  <li><strong>Domains</strong> - Allow for default and custom domains associated with APIs.</li>
  <li><strong>Certificates</strong> - Provide management and usage of certificates for encryption.</li>
  <li><strong>Tags</strong> - Allow APIs, as well as their individual paths, and requests to be tagged.</li>
  <li><strong>Dependencies</strong> - Inform on the dependencies between APIs, including 3rd party.</li>
  <li><strong>Regions</strong> - Allow for multi-region deployment of APIs, with full DNS support.</li>
  <li><strong>Contact</strong> - Ensure there is contact information for every API owner.</li>
  <li><strong>Logging</strong> - Standardize the logging for all API traffic to one or many locations.</li>
  <li><strong>Monitoring</strong> - Provide basic monitoring of all APIs from alternate locations.</li>
  <li><strong>Status</strong> - Offer a real time status dashboard and notification for all APIs.</li>
  <li><strong>Terms of Service</strong> - Allow for the publishing of one or many TOS applying to APIs.</li>
  <li><strong>Authentication</strong> - Provide a handful of standard authentication mechanisms.</li>
  <li><strong>Authorization</strong> - Enable fine grade authorization across APIs and schema.</li>
  <li><strong>Consumers</strong> - Allow for consumers to sign up and maintain access accounts.</li>
  <li><strong>Keys</strong> - Require consumers define their applications and use API keys with API calls.</li>
  <li><strong>Documentation</strong> - Automatically publish documentation for all APIs that are published.</li>
  <li><strong>Reporting</strong> - Provide reporting on all gateway activity across each API and the lifecycle.
    <ul>
      <li><strong>Platform</strong> - Deliver platform specific API consumption report.</li>
      <li><strong>Consumer</strong> - Provide consumer specific API consumption reports.</li>
    </ul>
  </li>
</ul>

<p>I’m going to add these to my API gateway research. I’m sure there are other building blocks out there, but I think this is a good start. It reflects what I think makes API gateways different from API management. It has the design, deployment, and backend integration portion of the conversation, as well as the key API management features expected. I see API gateways as a Venn diagram of API lifecycle features. Providing a single blueprint, tooling, and appliance that will help you deliver, manage, distribute, and scale your API infrastructure.

<p><a href="https://github.com/api-evangelist/api-gateway-blueprint">You can find this outline published over at GitHub</a>. I will me managing it as a living document and opening up to feedback via GitHub issues. I’m going to evolve this as a core API gateway specification—eventually defining APIs and schema for each layer of the stack. This will take some time because I will have to profile several of the existing API gateway APIs and mine them for logical patterns. Borrowing from their API designs, and schema, layering them together to create a common set of building blocks. I’m going to also begin iterating upon what I’d call an observable regulatory set of API gateway building blocks to augment this existing list. Establishing my vision of not just an API gateway standard, which can be used internally, as well as openly as part of an industry-wide effort to deliver consistent APIs for a collective purpose.

