---
published: true
layout: post
title: 'A Postman Collection for Managing the Life Cycles Of My APIs'
image: https://s3.amazonaws.com/kinlane-productions2/algorotoscope-master/udnie-IMG_2410.jpg
---
<p><img style="padding: 15px;" src="https://s3.amazonaws.com/kinlane-productions2/algorotoscope-master/udnie-IMG_2410.jpg" alt="" width="40%" align="right" /></p>
<p>I had grown weary of just researching, talking, and teaching about the API lifecycle over the last ten years as the API Evangelist. This was one of the major motivators for me to join the Postman team. I want to take my knowledge of the API life cycle and work to make sure the rubber meet the road a little more when it comes to actually realizing much of what I talk about. I began investing in this vision over the holidays <a href="https://documenter.postman.com/view/35240/SWLb99h1?version=latest">by crafting a Postman collection that isn't for defining a single API, it is meant to define the life cycle of a single API</a>. I can manage multiple stops along the API life cycle already with Postman--I just wanted to bring it all together into a single machine readable collection that uses the Postman API, but also other APIs I use to orchestrate my world each day.</p>
<p>My <a href="https://documenter.postman.com/view/35240/SWLb99h1?version=latest">API life cycle collection</a> is still a work in progress, but it is coming together nicely, and is the most tangle format of what I have been in my head when I think of <a href="https://www.postman.com/">Postman as an API delivery platform</a>. This collection centers around managing an OpenAPI truth within Postman, then moving this API definition down the life cycle, and even deploy development or production versions of each API using AWS API Gateway. Of course everythig is API-driven, and designed to work across many different APIs to define, deliver, and manage any single API, maintaning a definition of the life cycle within a single Postman environment that can be used to bridge multiple API platform via a single collection.</p>
<p>So far I have over a hundred individual capabilities defined as Postman requests, and organized into folders that are broken down by different stops along the API life cycle. I'm still moving them around and abstracting away the friction, while I work hard to define the most sensible workflows with each of my API life cycle capabilities.</p>
<ul>
<li><strong>Define</strong> 
<ul>
<li><strong>Workspaces</strong> (Postman)  
<ul>
<li>GET Single Workspace</li>
<li>GET All Workspaces</li>
<li>POST Create Workspace</li>
</ul>
</li>
<li><strong>Organizations</strong> (GItHub)  
<ul>
<li>GET Organizations</li>
<li>GET Organization</li>
</ul>
</li>
<li><strong>Repository</strong> (GitHub)  
<ul>
<li>POST Add User Repository</li>
<li>POST Add Org Repository</li>
<li>GET Repository</li>
<li>GET Repositories</li>
</ul>
</li>
<li><strong>APIs</strong> 
<ul>
<li>GET Single API</li>
<li>GET Get all APIs</li>
<li>GET Get All API Versions</li>
<li>GET Get An API Version</li>
<li>GET Get API Schema</li>
</ul>
</li>
<li><strong>Collections</strong> 
<ul>
<li>GET All Collections</li>
<li>GET Single Collection</li>
<li>POST Create Collection</li>
<li>PUT Update Collection</li>
<li>DELETE Delete Collection</li>
</ul>
</li>
<li>POST Create Manually</li>
<li>GET OpenAPI Using Name and Version</li>
<li>GET Sync OpenAPI To GitHub Repository</li>
<li>GET Sync OpenAPI From GitHub Repository</li>
</ul>
</li>
<li><strong>Environments</strong> (Postman)  
<ul>
<li>GET Environments</li>
<li>GET Environment</li>
<li>POST Environment</li>
<li>PUT Environment</li>
<li>DELETE Environment</li>
</ul>
</li>
<li><strong>Design</strong> (Postman)  
<ul>
<li>POST Add Resource</li>
<li>POST Add Schema Property</li>
<li>POST Add Query Parameter</li>
<li>POST Add Header</li>
<li>POST Add Response</li>
</ul>
</li>
<li><strong>Documentation</strong> (Postman)  
<ul>
<li>POST Sets Documentation URL</li>
</ul>
</li>
<li><strong>Mock</strong> (Postman)  
<ul>
<li>GET Mocks</li>
<li>GET Mock</li>
<li>POST Mock</li>
<li>DELETE Mock</li>
</ul>
</li>
<li><strong>Database</strong> (AWS DynamoDB)  
<ul>
<li>POST List Tables</li>
<li>POST Add Table</li>
</ul>
</li>
<li><strong>Compute</strong> (AWS Lambda)  
<ul>
<li>GET Funtions</li>
<li>GET Function</li>
</ul>
</li>
<li><strong>Deploy</strong>&nbsp;(AWS API Gateway)  
<ul>
<li>GET List</li>
<li>GET Details</li>
<li>GET Build</li>
<li>POST Publish</li>
<li>POST Deploy</li>
<li>GET Deployment</li>
<li>GET Export OpenAPI 3.0</li>
<li>DELETE Delete</li>
</ul>
</li>
<li><strong>Manage</strong> - AWS API Gateway  
<ul>
<li><strong>Usage Plans</strong> 
<ul>
<li>GET All</li>
<li>GET Single</li>
<li>POST Add</li>
<li>GET Get Usage</li>
</ul>
</li>
<li><strong>Keys</strong> 
<ul>
<li>GET All</li>
<li>GET Single</li>
<li>POST Add</li>
<li>POST Usage Plan Keys</li>
</ul>
</li>
</ul>
</li>
<li><strong>Logging</strong> (AWS API CloudTrail)  
<ul>
<li>GET Trails</li>
<li>GET Trails Cop</li>
</ul>
</li>
<li><strong>Encryption</strong> 
<ul>
<li>GET List CloudFlare Certificates</li>
<li>GET AWS API Gateway Client Certificates</li>
<li>POST Generate Client Certificate</li>
<li>GET AWS API Gateway Client Certificate</li>
<li>DELETE AWS API Gateway Client Certificate</li>
</ul>
</li>
<li><strong>DNS</strong> 
<ul>
<li>GET Zones (CloudFlare)</li>
<li>GET DNS Records (CloudFlare)</li>
<li>GET Domain Names (AWS API Gateway)</li>
<li>GET Domain Name (AWS API Gateway)</li>
</ul>
</li>
<li><strong>Portal</strong> (GitHub)  
<ul>
<li>POST Add Org Repository</li>
<li>POST Add User Repository</li>
<li>POST Update README</li>
</ul>
</li>
<li><strong>Road Map</strong> (GitHub)  
<ul>
<li>GET All Road Map Items</li>
<li>POST New Road Map Item</li>
<li>GET Single Road Map Item</li>
<li>PATCH Mark Complete</li>
</ul>
</li>
<li><strong>Change Log </strong>(GitHub)  
<ul>
<li>GET All Change Log Entries</li>
<li>POST New Change Log Entry</li>
<li>GET Single Change Log Entry</li>
<li>PATCH Close Change Log Entry</li>
</ul>
</li>
<li><strong>Issues</strong> (GitHub)  
<ul>
<li>GET All Issues</li>
<li>POST New Issue</li>
<li>GET Single Issue</li>
<li>PATCH Close Issue</li>
</ul>
</li>
<li><strong>Support</strong> (GitHub)  
<ul>
<li>GET All Tickets</li>
<li>POST New Ticket</li>
<li>GET Single Ticket</li>
<li>PATCH Close Ticket</li>
</ul>
</li>
<li><strong>Communication</strong> (GitHub)  
<ul>
<li><strong>Blog</strong> 
<ul>
<li>POST Blog Post</li>
<li>GET Blog Posts</li>
<li>GET Blog Post</li>
</ul>
</li>
<li><strong>Twitter</strong> 
<ul>
<li>POST Tweet</li>
<li>GET Twitter Tweet Search</li>
<li>GET Twitter User Search</li>
</ul>
</li>
</ul>
</li>
<li><strong>Testing</strong> (Postman)</li>
<li><strong>Monitoring</strong> (Postman)</li>
<li><strong>Performance</strong> (Postman)</li>
<li><strong>Security</strong></li>
<li><strong>Discovery</strong> (GitHub)  
<ul>
<li>POST Update APIs.json</li>
</ul>
</li>
<li><strong>Governance</strong> 
<ul>
<li><strong>Design</strong> 
<ul>
<li>Info</li>
<li>Paths</li>
<li>Methods</li>
<li>Parameters</li>
<li>Responses</li>
<li>Schema</li>
</ul>
</li>
<li><strong>Mock</strong> 
<ul>
<li>GET Check To See If Their Is A Mock Server</li>
</ul>
</li>
<li><strong>Develpment</strong> 
<ul>
<li>GET Check To See If Their Is A Development Server</li>
</ul>
</li>
<li><strong>LIcense</strong> 
<ul>
<li>GET Validate the License for the API</li>
</ul>
</li>
<li><strong>Production</strong> 
<ul>
<li>GET Check To See If Their Is A Production Server</li>
</ul>
</li>
<li><strong>Reporting</strong> 
<ul>
<li>GET Life Cycle Outline</li>
</ul>
</li>
</ul>
</li>
<li><strong>Deprecation</strong> 
<ul>
<li>GET Set Sunset HTTP Header</li>
<li>POST Add Deprecation Date To Road Map</li>
</ul>
</li>
</ul>
<p>To help me refine <a href="https://documenter.postman.com/view/35240/SWLb99h1?version=latest">this API life cycle collection</a>&nbsp;a little more I am going to apply to around ten individual APIs I want to move forward. Three of them are for demonstration purposes, but the rest are menat for a research project I am working on. My initial goal here was to flesh out an API design first process for delivering the resources I need, but then quickly moved to being able to actulaly deliver, then rapidly evolve these resources in both development and produciton environments. They aren't resources that will ultimately see a lot of activity, or true production scale, but they will be used enough to flesh out my API life cycle in a meaningful way.&nbsp;</p>
<p>In addition to helping me realize a more API-driven approach to the API life cycle, there are two major takeaways for me from this project so far. First, I am able to go from an OpenAPI truth within Postman, to deploying a usable API using AWS API Gateway and AWS DynamoDB within just a couple clicks. Second, I was able to start delivering a meaningful set of API governance requests that I organize as part of the governance section of this collection--helping me look for some of the most common things that go wrong with my API design. There are many other little nuggets in here for me, which I will be writing about separately. There is a lot to unpack here, and I will be digging in via stories on the blog over the next couple of weeks.</p>